---
title: "Loan Repayment and borrower analysis"
output: 
      rmdformats::downcute:
        code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include = FALSE, message=FALSE}
# Loading Libraries
libs <- c("dplyr", "tidyr", "data.table", "ggplot2", "caret", "caTools", "car", "MASS", "gridExtra", "broom", "DT", "randomForest")
lapply(libs, require, character.only = T)
```
# The Loan Data
```{r loading data, message=FALSE}
# loading data
data <- fread("data/loan_data.csv")
data <-  data %>%
        mutate(not.fully.paid = factor(ifelse(not.fully.paid == 1, "Yes", "No")),
               credit.policy = factor(ifelse(credit.policy == 1, "Yes", "No")),
               annual.inc = exp(log.annual.inc),
               days = round(data$days.with.cr.line))

```

| Variable  | class     | description                    |
|:----------|:----------|:-------------------------------|
| credit.policy   | numeric | 1 if the customer meets the credit underwriting criteria; 0 otherwise. |
| purpose      | character | The purpose of the loan. |
| int.rate      | numeric   | The interest rate of the loan (more risky borrowers are assigned higher interest rates).  |
| installment  | numeric   | The monthly installments owed by the borrower if the loan is funded. |
| log.annual_inc | numeric   | The natural log of the self-reported annual income of the borrower. |
| dti | numeric   | The debt-to-income ratio of the borrower (amount of debt divided by annual income). |
| fico | numeric   | The FICO credit score of the borrower. |
| days.with.cr.line | numeric   | The number of days the borrower has had a credit line. |
| revol.bal | numeric   | The borrower's revolving balance (amount unpaid at the end of the credit card billing cycle). |
| revol.util | numeric   | The borrower's revolving line utilization rate (the amount of the credit line used relative to total credit available). |
| inq.last.6mths | numeric   | The borrower's number of inquiries by creditors in the last 6 months. |
| delinq.2yrs | numeric   | The number of times the borrower had been 30+ days past due on a payment in the past 2 years. |
| pub.rec | numeric   | The borrower's number of derogatory public records.
| not.fully.paid | numeric   | 1 if the loan is not fully paid; 0 otherwise.

# Purpose

For this analysis, the intent is:
  - Categorize individuals based on their borrower behavior, possibly determining qualities or a set of qualities that individuals exhibit effecting possible FICO score, successful completion of loan payment, or the duration until the loan is repaid.
  - To predict whether a person will repay their loan to completion or not and to predict the duration until a person repays their loan.
This analysis will be able to help lenders and borrowers by providing information for a borrower to alter their behavior so that they can possibly receive a lower interest rate, and increase their FICO score by imitating behavior in those with higher FICO scores. Moreover, borrowers will be able to predict the possibility that a person doesn't pay their loan completely so they can decide whether or not to engage with those borrowers.

# Exploratory Data Analysis
## Exploring Possible response variables
### Examining fully paid 
```{r, message=FALSE}
data %>%
ggplot(aes(x = factor(not.fully.paid), fill = not.fully.paid)) +
  geom_bar() +
  labs(x = "Default", y = "Count", title = "Number of Clients who did and did not Default") +
  theme_minimal() +
  theme(legend.position = "none")

fully_paid_prop <- data %>%
  summarize(prop = mean(not.fully.paid == "No")) %>%
  pull()

Counts <- data %>%
  count(not.fully.paid)
```

  When looking at the number of people who defaulted (did not completely pay off the loan) on their loan, there is a significant difference between the number of individuals who have paid off their loans completely vs those who defaulted on it. With around `r fully_paid_prop*100`% (`r Counts[1,2]`) paying off their loans completely and around `r (1-fully_paid_prop)*100`% (`r Counts[2,2]`) defaulting on their loans, this as a response variable is unbalanced and will require balancing during the prediction process. 


### Examining days with credit line
```{r, message=FALSE, out.height = "150%"}
days_his1 <- data %>% 
  ggplot(aes(x = days.with.cr.line, color = factor(not.fully.paid))) +
  geom_histogram() +
  labs(x = "Days with Credit Line", y = "Count", title = "Histogram of Days with Credit Line by Defaults", color = "Default") +
  theme_minimal()

days_his2 <- data %>% 
  ggplot(aes(x = days.with.cr.line, color = factor(purpose))) +
  geom_histogram() +
  labs(x = "Days with Credit Line", y = "Count", title = "Histogram of Days with Credit Line by Purpose", color = "Purpose") +
  scale_color_discrete(labels = c("Other", "Credit Card", "Debt Consolidation", "Educational", "Home Improvement", "Major Purchase", "Small Business")) +
  theme_minimal()

grid.arrange(days_his1, days_his2)
```

Based on the histograms above, the distribution of days with a credit line stays relatively identical across the different populations when accounting for either defaults or by the purpose of the loans. Moreover, as the population increases, within the groups, it appears to approach a right-tail skewed normal distribution.

### Delinquency
```{r, message=FALSE, out.height = "150%"}
# Public Record
D1 <- ggplot(data, aes(factor(pub.rec), fico, fill = factor(pub.rec))) +
  geom_boxplot() +
  labs(x = "Number of derogatory Public Records", y = "FICO Score", title = "Box Plot of number of FICO against the number of derogatory Public Records") +
  theme_minimal() +
  theme(legend.position = "none")

# Delinquencies
D2 <- ggplot(data, aes(factor(delinq.2yrs), int.rate, fill = factor(delinq.2yrs))) +
  geom_boxplot() +
  labs(x = "Number of Delinquencies in 2 years", y = "Interest Rate", title = "Box Plot of number of interest rate against the Number of Delinquencies in 2 years") +
  theme_minimal() +
  theme(legend.position = "none")
  
D3 <- ggplot(data, aes(factor(delinq.2yrs), log.annual.inc, fill = factor(delinq.2yrs))) +
  geom_boxplot() +
  labs(x = "FICO Score", y = "Interest Rate", title = "Box Plot of number of FICO against the Number of Delinquencies in 2 years") +
  theme_minimal() +
  theme(legend.position = "none")
grid.arrange(D1, D2, D3)
```

When looking at the delinquencies and the number of derogatory public records, there isn't a visually significant difference between the medians FICO score and interest rate; however it does appear that individuals with more derogatory public records tend to have a lower FICO score and individuals with more delinquencies tend to have a higher interest rate. Although, this is not statistically confirmed.

# Inferential Modeling
## Linear Model Visualizations against Fico Score
```{r message = FALSE, out.height = "500%"}
LM_V1 <- data %>% 
  ggplot(aes(x = fico, y = days.with.cr.line, color = not.fully.paid)) +
  geom_point() +
  geom_smooth(method = "lm") +
  theme_minimal() +
  labs(x = "FICO Score", y = "Days with Credit Line", color = "Not Fully Paid")

LM_V2 <- data %>%
  ggplot(aes(x = fico, y = int.rate, color = not.fully.paid)) +
  geom_point() +
  geom_smooth(method = "lm") +
  theme_minimal()+
  labs(x = "FICO Score", y = "Interest Rate", color = "Not Fully Paid")

LM_V3 <- data %>% 
  ggplot(aes(x = fico, y = revol.util, color = not.fully.paid)) +
  geom_point() +
  geom_smooth(method = "lm") +
  theme_minimal() +
  labs(x = "FICO Score", y = "Revolving Utilization of Debt (%)", color = "Not Fully Paid")

LM_V4 <- data %>% 
  ggplot(aes(x = fico, y = installment, color = not.fully.paid)) +
  geom_point() +
  geom_smooth(method = "lm") +
  theme_minimal() +
  labs(x = "FICO Score", y = "Installment (USD)", color = "Not Fully Paid")

grid.arrange(LM_V1, LM_V2, LM_V3, LM_V4)
```


## Linear Models Results
```{r, out.width = "200%"}
Simple_ficos <- lm(cbind(days.with.cr.line, int.rate, revol.util) ~ fico, data = data)
datatable(tidy(Simple_ficos))
```


```{r}
data %>%
  ggplot(aes(x = fico, y = log.annual.inc)) +
  geom_point() +
  geom_smooth(method = "lm")

data %>%
  ggplot(aes(x = not.fully.paid, y = installment)) +
  geom_boxplot()
```

##
```{r}
data %>%
  ggplot(aes(x = log.annual.inc, y = days.with.cr.line, color = not.fully.paid)) +
  geom_point() +
  geom_smooth(method = "lm")
```


# Model Analysis
## Determining factors contributing to a person defaulting on the loan
```{r}
summary(complete_binomial <- glm(formula = not.fully.paid ~ . - days - annual.inc, data = data, family = "binomial"))
Stepwise_binomial <- stepAIC(complete_binomial, direction = "both")
summary(Stepwise_binomial)
vif(Stepwise_binomial)
```



## Determining factors contributing to days with the credit line
```{r}
lm(days.with.cr.line ~ fico, data = data) %>% summary()
lm(days.with.cr.line ~ log.annual.inc + poly(fico, 3), data = data) %>% summary()
complete_days <- lm(days.with.cr.line ~ .- days - annual.inc - not.fully.paid, data = data)
forward_selection <- stepAIC(complete_days, direction = "forward")
summary(forward_selection)
vif(forward_selection)
```


## Gamma Regression
### Estimating Days with credit line based on character traits
```{r}
# Variables of interest: 
##
plot(log(days) ~ fico, data = data)
plot((1/days) ~ fico, data = data)
summary(pois_reg <- glm(days ~ int.rate*fico + I(int.rate^2), data = data, family = Gamma(link = "log")))
summary(pois_reg <- glm(days ~ . + I(int.rate^2), data = data, family = Gamma(link = "log")))
test_data <- data[runif(500, min = 0, max = nrow(data)),]
pred <- predict(pois_reg, newdata = test_data, type = "response")
actual <- test_data[,days.with.cr.line]

pchisq(pois_reg$deviance, pois_reg$df.residual, lower.tail=F)

plot(pois_reg)
plot(pred, actual)
plot(log(pred), actual)
hist(pred)
hist(actual)

summary(lm(actual ~ log(pred)))
```

### Gamma Regression Model Stacking (Prediction Oriented)
```{r}



```




```{r}
# Cluster Analysis and Dimensionality reduction

# summary(pr <- prcomp(data[,c("fico", "revol.util", "days.with.cr.line", "dti")], scale = T))
# biplot(pr)
# km1 <- kmeans(scaled, centers = 3, nstart = 1000)
# plot(data$fico, data$days.with.cr.line , col = km1$cluster)
```

```{r}
# (pr <- prcomp(data[,c(3,6,7,9,10)], scale = T))
# summary(pr)
# biplot(pr)
# plot(pr$x[,c(1,2)], col = as.factor(data$not.fully.paid))
# plot(pr$x[,c(1,3)], col = as.factor(data$not.fully.paid))
# plot(pr$x[,c(2,3)], col = as.factor(data$not.fully.paid))
# 
# km1 <- kmeans(pr$x[,1:3], centers = 3, nstart = 1000)
# plot(pr$x[,1:2], col = km1$cluster)
# table(km1$cluster, data$not.fully.paid)
```

```{r}
# (pr <- prcomp(data[,c(3,6,7,9,10)], scale = T))
# summary(pr)
# biplot(pr)
# plot(pr$x[,c(1,2)], col = as.factor(data$not.fully.paid))
# plot(pr$x[,c(1,3)], col = as.factor(data$not.fully.paid))
# plot(pr$x[,c(2,3)], col = as.factor(data$not.fully.paid))
# 
# km1 <- kmeans(pr$x[,1:3], centers = 3, nstart = 1000)
# plot(pr$x[,1:2], col = km1$cluster)
# table(km1$cluster, data$not.fully.paid)
```


# Machine Learning Prediction Models using Caret
## 
```{r}
# set.seed(0)
# ind <- sample(nrow(data), size = round(nrow(data)*.8))
# train <- data[ind,]
# test <- data[-ind,]
# 
# 
# formula1 =  not.fully.paid ~ . - annual.inc - days - pub.rec
# 
# 
# ctrl <- trainControl(method = "repeatedcv", repeats = 5,
#                      classProbs = TRUE,
#                      summaryFunction = twoClassSummary,
#                      sampling = "down")
# 
# 
# gbm <- train(formula1,
#              data = train,
#              method = "gbm",
#              metric = "ROC",
#              verbose = F,
#              trControl = ctrl)
# probs <- predict(gbm, test, type = "prob")
# preds <- ifelse(probs[1] > .50, "No", "Yes")
# table(preds, Actual = test$credit.policy)
# 
# 
# rf <- train(formula1,
#              data = train,
#              method = "rf",
#              metric = "ROC",
#              verbose = F,
#              trControl = ctrl)
# probs <- predict(rf, test, type = "prob")
# preds <- ifelse(probs[1] > .50, "No", "Yes")
# table(preds, Actual = test$credit.policy)
# 
# 
# 
# ada <- train(formula1,
#              data = train,
#              method = "adaboost",
#              metric = "ROC",
#              verbose = F,
#              trControl = ctrl)
# probs <- predict(ada, test, type = "prob")
# preds <- ifelse(probs[1] > .50, "No", "Yes")
# table(preds, Actual = test$credit.policy)
# 

```


# Conclusion